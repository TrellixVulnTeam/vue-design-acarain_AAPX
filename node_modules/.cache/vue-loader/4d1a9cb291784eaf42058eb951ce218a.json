{"remainingRequest":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/indriyantongrh/Sites/projectacarain/acarain/src/components/vue-horizontal-list.vue?vue&type=style&index=0&id=77a38880&scoped=true&lang=css&","dependencies":[{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/src/components/vue-horizontal-list.vue","mtime":1619933376410},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoudnVlLWhvcml6b250YWwtbGlzdCB7CiAgcG9zaXRpb246IHJlbGF0aXZlOwp9Ci52aGwtbmF2aWdhdGlvbiB7CiAgZGlzcGxheTogZmxleDsKICBhbGlnbi1pdGVtczogY2VudGVyOwogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICB3aWR0aDogMTAwJTsKICBoZWlnaHQ6IDEwMCU7CiAgbWFyZ2luLXRvcDogLTZweDsKfQoudmhsLWJ0bi1sZWZ0LAoudmhsLWJ0bi1yaWdodCB7CiAgd2lkdGg6IDQ4cHg7CiAgaGVpZ2h0OiA0OHB4OwogIGRpc3BsYXk6IGZsZXg7CiAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICBib3JkZXItcmFkaXVzOiAyNHB4OwogIGJhY2tncm91bmQ6IHdoaXRlOwogIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDFweCAycHggcmdiYSgwLCAwLCAwLCAwLjI0KTsKICB6LWluZGV4OiAyOwp9Ci52aGwtYnRuLWxlZnQ6aG92ZXIsCi52aGwtYnRuLXJpZ2h0OmhvdmVyIHsKICBjdXJzb3I6IHBvaW50ZXI7Cn0KLnZobC1idG4tbGVmdCB7CiAgbWFyZ2luLWxlZnQ6IC0yNHB4OwogIG1hcmdpbi1yaWdodDogYXV0bzsKfQoudmhsLWJ0bi1yaWdodCB7CiAgbWFyZ2luLWxlZnQ6IGF1dG87CiAgbWFyZ2luLXJpZ2h0OiAtMjRweDsKfQoudmhsLWNvbnRhaW5lciB7CiAgb3ZlcmZsb3cteTogaGlkZGVuOwogIGhlaWdodDogMTAwJTsKICBtYXJnaW4tYm90dG9tOiAtMjRweDsKfQoudmhsLWxpc3QgewogIGRpc3BsYXk6IGZsZXg7CiAgcGFkZGluZy1ib3R0b206IDI0cHg7CiAgbWFyZ2luLWJvdHRvbTogLTI0cHg7CiAgb3ZlcmZsb3cteDogc2Nyb2xsOwogIG92ZXJmbG93LXk6IGhpZGRlbjsKICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDsKICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7CiAgc2Nyb2xsLXNuYXAtdHlwZTogeCBtYW5kYXRvcnk7Cn0KLnZobC1pdGVtIHsKICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsKICBwYWRkaW5nLXRvcDogMjRweDsKICBwYWRkaW5nLWJvdHRvbTogMjRweDsKICB6LWluZGV4OiAxOwogIC8qIFByZXZlbnQgY29udGVudCBmcm9tIGNvbGxhcHNpbmcgd2hlbiBlbXB0eS4gRS5nLiBpbWFnZSB3aGlsZSBsb2FkaW5nIGhlaWdodD0wLiAqLwogIG1pbi1oZWlnaHQ6IDFweDsKfQoudmhsLWxpc3QgPiAqIHsKICBzY3JvbGwtc25hcC1hbGlnbjogc3RhcnQ7CiAgZmxleC1zaHJpbms6IDA7Cn0K"},{"version":3,"sources":["vue-horizontal-list.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vue-horizontal-list.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"vue-horizontal-list\" ref=\"container\">\n    <div class=\"vhl-navigation\" v-if=\"width.window > _options.navigation.start\">\n      <div @click=\"prev\" v-if=\"_hasPrev\" class=\"vhl-btn-left\">\n        <slot name=\"nav-prev\">\n          <svg\n            :fill=\"_options.navigation.color\"\n            width=\"32px\"\n            height=\"32px\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              d=\"M10.757 12l4.95 4.95a1 1 0 1 1-1.414 1.414l-5.657-5.657a1 1 0 0 1 0-1.414l5.657-5.657a1 1 0 0 1 1.414 1.414L10.757 12z\"\n            />\n          </svg>\n        </slot>\n      </div>\n\n      <div @click=\"next\" v-if=\"_hasNext\" class=\"vhl-btn-right\">\n        <slot name=\"nav-next\">\n          <svg\n            :fill=\"_options.navigation.color\"\n            width=\"32px\"\n            height=\"32px\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              d=\"M13.314 12.071l-4.95-4.95a1 1 0 0 1 1.414-1.414l5.657 5.657a1 1 0 0 1 0 1.414l-5.657 5.657a1 1 0 0 1-1.414-1.414l4.95-4.95z\"\n            />\n          </svg>\n        </slot>\n      </div>\n    </div>\n\n    <div class=\"vhl-container\" :style=\"_style.container\">\n      <div\n        class=\"vhl-list\"\n        ref=\"list\"\n        :class=\"_options.list.class\"\n        :style=\"_style.list\"\n        @scroll=\"scrollHandler\"\n      >\n        <!-- <div\n          v-for=\"item in _items\"\n          ref=\"item\"\n          class=\"vhl-item\"\n          :class=\"_options.item.class\"\n          :style=\"_style.item\"\n        > -->\n          <slot v-if=\"item.type === 'start'\" name=\"start\"></slot>\n          <slot v-else-if=\"item.type === 'end'\" name=\"end\"></slot>\n          <slot v-else-if=\"item.type === 'item'\" v-bind:item=\"item.item\">{{\n            item\n          }}</slot>\n        </div>\n\n        <div :style=\"_style.tail\"></div>\n      </div>\n    </div>\n  \n</template>\n\n<script>\nexport default {\n  name: \"VueHorizontalList\",\n  props: {\n    /**\n     * items to display in horizontal-list\n     */\n    items: {\n      type: Array,\n      required: true,\n    },\n    /**\n     * item.class = css class for each individual item.\n     * item.padding = padding between each item in the list.\n     *\n     * list.class = css class for the parent of item\n     * list.windowed = maximum width of the list it can extend to, basically the container max-width\n     * list.padding = padding of the list, if container < windowed what is the left-right padding of the list\n     *\n     * responsive breakpoints to calculate how many items to show in the list at each width interval\n     * Examples:\n     * [{size: 5}] show 5 items regardless\n     * [{end: 992, size: 3}},{size: 4}] < 992 show 3 items, else show 4 items\n     * [{end: 576, size: 1}, {start: 576, end: 992, size: 2}, {size: 3}] < 576 show 1, 576 - 992 show 2, else show 3\n     *\n     * These are the default responsive fallback, if you don't have a catch all, it will fallback to this.\n     * [{end: 576, size: 1},\n     * {start: 576, end: 768, size: 2},\n     * {start: 768, end: 992, size: 3},\n     * {start: 992, end: 1200, size: 4},\n     * {start: 1200, size: 5}]\n     */\n    options: {\n      type: Object,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      /**\n       * Current item position of list\n       */\n      position: 0,\n      /**\n       * Width of item, list and window\n       */\n      width: {\n        container: 0,\n        window: 576,\n      },\n      /**\n       * Debounce timer of the scroll\n       */\n      scrollTimer: null,\n      /**\n       * Interval of the autoPlay\n       */\n      autoPlayInterval: null,\n    };\n  },\n  mounted() {\n    this.$resize = () => {\n      this.width.window = window.innerWidth;\n      this.width.container = this.$refs.container.clientWidth;\n    };\n    // TODO(fuxing): Need to re-do this\n    // Added a simple SSR fix, need to look into it for optimization in the future\n    require(\"smoothscroll-polyfill\").polyfill();\n    this.$resize();\n    window.addEventListener(\"resize\", this.$resize);\n    if (this._options.position.start) {\n      this.$nextTick(() => {\n        this.go(this._options.position.start);\n      });\n    }\n    if (this._options.autoplay.play) {\n      this.runAutoPlay();\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener(\"resize\", this.$resize);\n    if (this.autoPlayInterval) {\n      clearInterval(this.autoPlayInterval);\n    }\n  },\n  computed: {\n    _items() {\n      return [\n        ...(this.$slots[\"start\"] ? [{ type: \"start\" }] : []),\n        ...this.items.map((value) => ({ type: \"item\", item: value })),\n        ...(this.$slots[\"end\"] ? [{ type: \"end\" }] : []),\n      ];\n    },\n    _length() {\n      return this._items.length;\n    },\n    _options() {\n      const options = this.options;\n      return {\n        navigation: {\n          start: options?.navigation?.start ?? 992,\n          // TODO(fuxing): Deprecate this in favor of navigation slot\n          color: options?.navigation?.color ?? \"#000\",\n        },\n        item: {\n          class: options?.item?.class ?? \"\",\n          padding: options?.item?.padding ?? 16,\n        },\n        list: {\n          class: options?.list?.class ?? \"\",\n          windowed: options?.list?.windowed ?? 1200,\n          padding: options?.list?.padding ?? 24,\n        },\n        responsive: [\n          ...(options?.responsive ?? []),\n          // Fallback default responsive\n          { end: 576, size: 1 },\n          { start: 576, end: 768, size: 2 },\n          { start: 768, end: 992, size: 3 },\n          { start: 992, end: 1200, size: 4 },\n          { start: 1200, size: 5 },\n        ],\n        position: {\n          start: options?.position?.start ?? 0,\n        },\n        autoplay: {\n          play: options?.autoplay?.play ?? false,\n          speed: options?.autoplay?.speed ?? 2000,\n          repeat: options?.autoplay?.repeat ?? false,\n        },\n      };\n    },\n    _style() {\n      const style = {\n        container: {},\n        list: {},\n        item: {},\n        tail: {},\n      };\n      const workingWidth = this._workingWidth;\n      const size = this._size;\n      // Full Screen Mode\n      if (this.width.window < this._options.list.windowed) {\n        style.container.marginLeft = `-${this._options.list.padding}px`;\n        style.container.marginRight = `-${this._options.list.padding}px`;\n        style.item.width = `${\n          (workingWidth - (size - 1) * this._options.item.padding) / size\n        }px`;\n        style.item.paddingLeft = `${this._options.list.padding}px`;\n        style.item.paddingRight = `${this._options.item.padding}px`;\n        style.item.marginRight = `-${this._options.list.padding}px`;\n      }\n      // Windowed Mode\n      else {\n        style.item.paddingLeft = `${this._options.item.padding / 2}px`;\n        style.item.paddingRight = `${this._options.item.padding / 2}px`;\n        style.container.marginLeft = `-${this._options.item.padding / 2}px`;\n        style.container.marginRight = `-${this._options.item.padding / 2}px`;\n        style.item.width = `${\n          (workingWidth - (size - 1) * this._options.item.padding) / size\n        }px`;\n      }\n      return style;\n    },\n    _itemWidth() {\n      return (\n        (this._workingWidth - (this._size - 1) * this._options.item.padding) /\n        this._size\n      );\n    },\n    /**\n     * @return number actual width of the container\n     */\n    _workingWidth() {\n      // Full Screen Mode\n      if (this.width.window < this._options.list.windowed) {\n        return this.width.window - this._options.list.padding * 2;\n      }\n      // Windowed Mode\n      else {\n        return this.width.container;\n      }\n    },\n    /**\n     * @return visible items in horizontal list at the current width/state\n     */\n    _size() {\n      const width = this._workingWidth;\n      return this._options.responsive.find((value) => {\n        return (\n          (!value.start || value.start <= width) &&\n          (!value.end || value.end >= width)\n        );\n      }).size;\n    },\n    /**\n     * @return boolean whether there is prev set of items for navigation\n     * @private internal use\n     */\n    _hasNext() {\n      return this._length > this.position + this._size;\n    },\n    /**\n     * @return boolean whether there is next set of items for navigation\n     * @private internal use\n     */\n    _hasPrev() {\n      return this.position > 0;\n    },\n  },\n  methods: {\n    /**\n     * @param position of item to scroll to\n     */\n    go(position) {\n      const maxPosition = this._length - this._size;\n      this.position = position > maxPosition ? maxPosition : position;\n      const left =\n        this._itemWidth * this.position +\n        this.position * this._options.item.padding;\n      this.$refs.list.scrollTo({ top: 0, left: left, behavior: \"smooth\" });\n    },\n    /**\n     * Run autoPlay slide show\n     */\n    runAutoPlay() {\n      this.autoPlayInterval = setInterval(\n        function () {\n          if (\n            this._options.autoplay.repeat &&\n            this.position === this._length - this._size\n          ) {\n            this.position = 0;\n            this.go(this.position);\n          } else {\n            this.position += 1;\n            this.go(this.position);\n          }\n        }.bind(this),\n        this._options.autoplay.speed\n      );\n    },\n    /**\n     * Stop autoPlay slide show\n     */\n    stopAutoPlay() {\n      clearInterval(this.autoPlayInterval);\n    },\n    /**\n     * Go to a set of previous items\n     */\n    prev() {\n      this.go(this.position - this._size);\n    },\n    /**\n     * Go to a set of next items\n     */\n    next() {\n      this.go(this.position + this._size);\n    },\n    /**\n     * On horizontal scroll re-evaluate the actual position\n     */\n    scrollHandler() {\n      clearTimeout(this.scrollTimer);\n      //Renew timer\n      this.scrollTimer = setTimeout(\n        function () {\n          const parentLeftOffset = this.$refs[\"list\"].getBoundingClientRect()\n            .left;\n          let items = this._items.map((item, index) => {\n            const itemLeftOffset = this.$refs.item[\n              index\n            ].getBoundingClientRect().left;\n            return Math.abs(itemLeftOffset - parentLeftOffset);\n          });\n          this.position = items.indexOf(Math.min(...items));\n        }.bind(this),\n        50\n      );\n    },\n  },\n  watch: {\n    \"options.autoplay.play\": function (newVal, oldVal) {\n      if (!newVal) {\n        this.stopAutoPlay();\n      } else {\n        this.runAutoPlay();\n      }\n    },\n  },\n};\n</script>\n<style scoped>\n.vue-horizontal-list {\n  position: relative;\n}\n.vhl-navigation {\n  display: flex;\n  align-items: center;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  margin-top: -6px;\n}\n.vhl-btn-left,\n.vhl-btn-right {\n  width: 48px;\n  height: 48px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 24px;\n  background: white;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n  z-index: 2;\n}\n.vhl-btn-left:hover,\n.vhl-btn-right:hover {\n  cursor: pointer;\n}\n.vhl-btn-left {\n  margin-left: -24px;\n  margin-right: auto;\n}\n.vhl-btn-right {\n  margin-left: auto;\n  margin-right: -24px;\n}\n.vhl-container {\n  overflow-y: hidden;\n  height: 100%;\n  margin-bottom: -24px;\n}\n.vhl-list {\n  display: flex;\n  padding-bottom: 24px;\n  margin-bottom: -24px;\n  overflow-x: scroll;\n  overflow-y: hidden;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n  scroll-snap-type: x mandatory;\n}\n.vhl-item {\n  box-sizing: content-box;\n  padding-top: 24px;\n  padding-bottom: 24px;\n  z-index: 1;\n  /* Prevent content from collapsing when empty. E.g. image while loading height=0. */\n  min-height: 1px;\n}\n.vhl-list > * {\n  scroll-snap-align: start;\n  flex-shrink: 0;\n}\n</style>"]}]}