{"remainingRequest":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/indriyantongrh/Sites/projectacarain/acarain/src/components/vue-horizontal-list.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/src/components/vue-horizontal-list.vue","mtime":1619933376410},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/indriyantongrh/Sites/projectacarain/acarain/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAiVnVlSG9yaXpvbnRhbExpc3QiLAogIHByb3BzOiB7CiAgICAvKioKICAgICAqIGl0ZW1zIHRvIGRpc3BsYXkgaW4gaG9yaXpvbnRhbC1saXN0CiAgICAgKi8KICAgIGl0ZW1zOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgIH0sCiAgICAvKioKICAgICAqIGl0ZW0uY2xhc3MgPSBjc3MgY2xhc3MgZm9yIGVhY2ggaW5kaXZpZHVhbCBpdGVtLgogICAgICogaXRlbS5wYWRkaW5nID0gcGFkZGluZyBiZXR3ZWVuIGVhY2ggaXRlbSBpbiB0aGUgbGlzdC4KICAgICAqCiAgICAgKiBsaXN0LmNsYXNzID0gY3NzIGNsYXNzIGZvciB0aGUgcGFyZW50IG9mIGl0ZW0KICAgICAqIGxpc3Qud2luZG93ZWQgPSBtYXhpbXVtIHdpZHRoIG9mIHRoZSBsaXN0IGl0IGNhbiBleHRlbmQgdG8sIGJhc2ljYWxseSB0aGUgY29udGFpbmVyIG1heC13aWR0aAogICAgICogbGlzdC5wYWRkaW5nID0gcGFkZGluZyBvZiB0aGUgbGlzdCwgaWYgY29udGFpbmVyIDwgd2luZG93ZWQgd2hhdCBpcyB0aGUgbGVmdC1yaWdodCBwYWRkaW5nIG9mIHRoZSBsaXN0CiAgICAgKgogICAgICogcmVzcG9uc2l2ZSBicmVha3BvaW50cyB0byBjYWxjdWxhdGUgaG93IG1hbnkgaXRlbXMgdG8gc2hvdyBpbiB0aGUgbGlzdCBhdCBlYWNoIHdpZHRoIGludGVydmFsCiAgICAgKiBFeGFtcGxlczoKICAgICAqIFt7c2l6ZTogNX1dIHNob3cgNSBpdGVtcyByZWdhcmRsZXNzCiAgICAgKiBbe2VuZDogOTkyLCBzaXplOiAzfX0se3NpemU6IDR9XSA8IDk5MiBzaG93IDMgaXRlbXMsIGVsc2Ugc2hvdyA0IGl0ZW1zCiAgICAgKiBbe2VuZDogNTc2LCBzaXplOiAxfSwge3N0YXJ0OiA1NzYsIGVuZDogOTkyLCBzaXplOiAyfSwge3NpemU6IDN9XSA8IDU3NiBzaG93IDEsIDU3NiAtIDk5MiBzaG93IDIsIGVsc2Ugc2hvdyAzCiAgICAgKgogICAgICogVGhlc2UgYXJlIHRoZSBkZWZhdWx0IHJlc3BvbnNpdmUgZmFsbGJhY2ssIGlmIHlvdSBkb24ndCBoYXZlIGEgY2F0Y2ggYWxsLCBpdCB3aWxsIGZhbGxiYWNrIHRvIHRoaXMuCiAgICAgKiBbe2VuZDogNTc2LCBzaXplOiAxfSwKICAgICAqIHtzdGFydDogNTc2LCBlbmQ6IDc2OCwgc2l6ZTogMn0sCiAgICAgKiB7c3RhcnQ6IDc2OCwgZW5kOiA5OTIsIHNpemU6IDN9LAogICAgICoge3N0YXJ0OiA5OTIsIGVuZDogMTIwMCwgc2l6ZTogNH0sCiAgICAgKiB7c3RhcnQ6IDEyMDAsIHNpemU6IDV9XQogICAgICovCiAgICBvcHRpb25zOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgfSwKICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICAvKioKICAgICAgICogQ3VycmVudCBpdGVtIHBvc2l0aW9uIG9mIGxpc3QKICAgICAgICovCiAgICAgIHBvc2l0aW9uOiAwLAogICAgICAvKioKICAgICAgICogV2lkdGggb2YgaXRlbSwgbGlzdCBhbmQgd2luZG93CiAgICAgICAqLwogICAgICB3aWR0aDogewogICAgICAgIGNvbnRhaW5lcjogMCwKICAgICAgICB3aW5kb3c6IDU3NiwKICAgICAgfSwKICAgICAgLyoqCiAgICAgICAqIERlYm91bmNlIHRpbWVyIG9mIHRoZSBzY3JvbGwKICAgICAgICovCiAgICAgIHNjcm9sbFRpbWVyOiBudWxsLAogICAgICAvKioKICAgICAgICogSW50ZXJ2YWwgb2YgdGhlIGF1dG9QbGF5CiAgICAgICAqLwogICAgICBhdXRvUGxheUludGVydmFsOiBudWxsLAogICAgfTsKICB9LAogIG1vdW50ZWQoKSB7CiAgICB0aGlzLiRyZXNpemUgPSAoKSA9PiB7CiAgICAgIHRoaXMud2lkdGgud2luZG93ID0gd2luZG93LmlubmVyV2lkdGg7CiAgICAgIHRoaXMud2lkdGguY29udGFpbmVyID0gdGhpcy4kcmVmcy5jb250YWluZXIuY2xpZW50V2lkdGg7CiAgICB9OwogICAgLy8gVE9ETyhmdXhpbmcpOiBOZWVkIHRvIHJlLWRvIHRoaXMKICAgIC8vIEFkZGVkIGEgc2ltcGxlIFNTUiBmaXgsIG5lZWQgdG8gbG9vayBpbnRvIGl0IGZvciBvcHRpbWl6YXRpb24gaW4gdGhlIGZ1dHVyZQogICAgcmVxdWlyZSgic21vb3Roc2Nyb2xsLXBvbHlmaWxsIikucG9seWZpbGwoKTsKICAgIHRoaXMuJHJlc2l6ZSgpOwogICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsIHRoaXMuJHJlc2l6ZSk7CiAgICBpZiAodGhpcy5fb3B0aW9ucy5wb3NpdGlvbi5zdGFydCkgewogICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgdGhpcy5nbyh0aGlzLl9vcHRpb25zLnBvc2l0aW9uLnN0YXJ0KTsKICAgICAgfSk7CiAgICB9CiAgICBpZiAodGhpcy5fb3B0aW9ucy5hdXRvcGxheS5wbGF5KSB7CiAgICAgIHRoaXMucnVuQXV0b1BsYXkoKTsKICAgIH0KICB9LAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIiwgdGhpcy4kcmVzaXplKTsKICAgIGlmICh0aGlzLmF1dG9QbGF5SW50ZXJ2YWwpIHsKICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9QbGF5SW50ZXJ2YWwpOwogICAgfQogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIF9pdGVtcygpIHsKICAgICAgcmV0dXJuIFsKICAgICAgICAuLi4odGhpcy4kc2xvdHNbInN0YXJ0Il0gPyBbeyB0eXBlOiAic3RhcnQiIH1dIDogW10pLAogICAgICAgIC4uLnRoaXMuaXRlbXMubWFwKCh2YWx1ZSkgPT4gKHsgdHlwZTogIml0ZW0iLCBpdGVtOiB2YWx1ZSB9KSksCiAgICAgICAgLi4uKHRoaXMuJHNsb3RzWyJlbmQiXSA/IFt7IHR5cGU6ICJlbmQiIH1dIDogW10pLAogICAgICBdOwogICAgfSwKICAgIF9sZW5ndGgoKSB7CiAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7CiAgICB9LAogICAgX29wdGlvbnMoKSB7CiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7CiAgICAgIHJldHVybiB7CiAgICAgICAgbmF2aWdhdGlvbjogewogICAgICAgICAgc3RhcnQ6IG9wdGlvbnM/Lm5hdmlnYXRpb24/LnN0YXJ0ID8/IDk5MiwKICAgICAgICAgIC8vIFRPRE8oZnV4aW5nKTogRGVwcmVjYXRlIHRoaXMgaW4gZmF2b3Igb2YgbmF2aWdhdGlvbiBzbG90CiAgICAgICAgICBjb2xvcjogb3B0aW9ucz8ubmF2aWdhdGlvbj8uY29sb3IgPz8gIiMwMDAiLAogICAgICAgIH0sCiAgICAgICAgaXRlbTogewogICAgICAgICAgY2xhc3M6IG9wdGlvbnM/Lml0ZW0/LmNsYXNzID8/ICIiLAogICAgICAgICAgcGFkZGluZzogb3B0aW9ucz8uaXRlbT8ucGFkZGluZyA/PyAxNiwKICAgICAgICB9LAogICAgICAgIGxpc3Q6IHsKICAgICAgICAgIGNsYXNzOiBvcHRpb25zPy5saXN0Py5jbGFzcyA/PyAiIiwKICAgICAgICAgIHdpbmRvd2VkOiBvcHRpb25zPy5saXN0Py53aW5kb3dlZCA/PyAxMjAwLAogICAgICAgICAgcGFkZGluZzogb3B0aW9ucz8ubGlzdD8ucGFkZGluZyA/PyAyNCwKICAgICAgICB9LAogICAgICAgIHJlc3BvbnNpdmU6IFsKICAgICAgICAgIC4uLihvcHRpb25zPy5yZXNwb25zaXZlID8/IFtdKSwKICAgICAgICAgIC8vIEZhbGxiYWNrIGRlZmF1bHQgcmVzcG9uc2l2ZQogICAgICAgICAgeyBlbmQ6IDU3Niwgc2l6ZTogMSB9LAogICAgICAgICAgeyBzdGFydDogNTc2LCBlbmQ6IDc2OCwgc2l6ZTogMiB9LAogICAgICAgICAgeyBzdGFydDogNzY4LCBlbmQ6IDk5Miwgc2l6ZTogMyB9LAogICAgICAgICAgeyBzdGFydDogOTkyLCBlbmQ6IDEyMDAsIHNpemU6IDQgfSwKICAgICAgICAgIHsgc3RhcnQ6IDEyMDAsIHNpemU6IDUgfSwKICAgICAgICBdLAogICAgICAgIHBvc2l0aW9uOiB7CiAgICAgICAgICBzdGFydDogb3B0aW9ucz8ucG9zaXRpb24/LnN0YXJ0ID8/IDAsCiAgICAgICAgfSwKICAgICAgICBhdXRvcGxheTogewogICAgICAgICAgcGxheTogb3B0aW9ucz8uYXV0b3BsYXk/LnBsYXkgPz8gZmFsc2UsCiAgICAgICAgICBzcGVlZDogb3B0aW9ucz8uYXV0b3BsYXk/LnNwZWVkID8/IDIwMDAsCiAgICAgICAgICByZXBlYXQ6IG9wdGlvbnM/LmF1dG9wbGF5Py5yZXBlYXQgPz8gZmFsc2UsCiAgICAgICAgfSwKICAgICAgfTsKICAgIH0sCiAgICBfc3R5bGUoKSB7CiAgICAgIGNvbnN0IHN0eWxlID0gewogICAgICAgIGNvbnRhaW5lcjoge30sCiAgICAgICAgbGlzdDoge30sCiAgICAgICAgaXRlbToge30sCiAgICAgICAgdGFpbDoge30sCiAgICAgIH07CiAgICAgIGNvbnN0IHdvcmtpbmdXaWR0aCA9IHRoaXMuX3dvcmtpbmdXaWR0aDsKICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemU7CiAgICAgIC8vIEZ1bGwgU2NyZWVuIE1vZGUKICAgICAgaWYgKHRoaXMud2lkdGgud2luZG93IDwgdGhpcy5fb3B0aW9ucy5saXN0LndpbmRvd2VkKSB7CiAgICAgICAgc3R5bGUuY29udGFpbmVyLm1hcmdpbkxlZnQgPSBgLSR7dGhpcy5fb3B0aW9ucy5saXN0LnBhZGRpbmd9cHhgOwogICAgICAgIHN0eWxlLmNvbnRhaW5lci5tYXJnaW5SaWdodCA9IGAtJHt0aGlzLl9vcHRpb25zLmxpc3QucGFkZGluZ31weGA7CiAgICAgICAgc3R5bGUuaXRlbS53aWR0aCA9IGAkewogICAgICAgICAgKHdvcmtpbmdXaWR0aCAtIChzaXplIC0gMSkgKiB0aGlzLl9vcHRpb25zLml0ZW0ucGFkZGluZykgLyBzaXplCiAgICAgICAgfXB4YDsKICAgICAgICBzdHlsZS5pdGVtLnBhZGRpbmdMZWZ0ID0gYCR7dGhpcy5fb3B0aW9ucy5saXN0LnBhZGRpbmd9cHhgOwogICAgICAgIHN0eWxlLml0ZW0ucGFkZGluZ1JpZ2h0ID0gYCR7dGhpcy5fb3B0aW9ucy5pdGVtLnBhZGRpbmd9cHhgOwogICAgICAgIHN0eWxlLml0ZW0ubWFyZ2luUmlnaHQgPSBgLSR7dGhpcy5fb3B0aW9ucy5saXN0LnBhZGRpbmd9cHhgOwogICAgICB9CiAgICAgIC8vIFdpbmRvd2VkIE1vZGUKICAgICAgZWxzZSB7CiAgICAgICAgc3R5bGUuaXRlbS5wYWRkaW5nTGVmdCA9IGAke3RoaXMuX29wdGlvbnMuaXRlbS5wYWRkaW5nIC8gMn1weGA7CiAgICAgICAgc3R5bGUuaXRlbS5wYWRkaW5nUmlnaHQgPSBgJHt0aGlzLl9vcHRpb25zLml0ZW0ucGFkZGluZyAvIDJ9cHhgOwogICAgICAgIHN0eWxlLmNvbnRhaW5lci5tYXJnaW5MZWZ0ID0gYC0ke3RoaXMuX29wdGlvbnMuaXRlbS5wYWRkaW5nIC8gMn1weGA7CiAgICAgICAgc3R5bGUuY29udGFpbmVyLm1hcmdpblJpZ2h0ID0gYC0ke3RoaXMuX29wdGlvbnMuaXRlbS5wYWRkaW5nIC8gMn1weGA7CiAgICAgICAgc3R5bGUuaXRlbS53aWR0aCA9IGAkewogICAgICAgICAgKHdvcmtpbmdXaWR0aCAtIChzaXplIC0gMSkgKiB0aGlzLl9vcHRpb25zLml0ZW0ucGFkZGluZykgLyBzaXplCiAgICAgICAgfXB4YDsKICAgICAgfQogICAgICByZXR1cm4gc3R5bGU7CiAgICB9LAogICAgX2l0ZW1XaWR0aCgpIHsKICAgICAgcmV0dXJuICgKICAgICAgICAodGhpcy5fd29ya2luZ1dpZHRoIC0gKHRoaXMuX3NpemUgLSAxKSAqIHRoaXMuX29wdGlvbnMuaXRlbS5wYWRkaW5nKSAvCiAgICAgICAgdGhpcy5fc2l6ZQogICAgICApOwogICAgfSwKICAgIC8qKgogICAgICogQHJldHVybiBudW1iZXIgYWN0dWFsIHdpZHRoIG9mIHRoZSBjb250YWluZXIKICAgICAqLwogICAgX3dvcmtpbmdXaWR0aCgpIHsKICAgICAgLy8gRnVsbCBTY3JlZW4gTW9kZQogICAgICBpZiAodGhpcy53aWR0aC53aW5kb3cgPCB0aGlzLl9vcHRpb25zLmxpc3Qud2luZG93ZWQpIHsKICAgICAgICByZXR1cm4gdGhpcy53aWR0aC53aW5kb3cgLSB0aGlzLl9vcHRpb25zLmxpc3QucGFkZGluZyAqIDI7CiAgICAgIH0KICAgICAgLy8gV2luZG93ZWQgTW9kZQogICAgICBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy53aWR0aC5jb250YWluZXI7CiAgICAgIH0KICAgIH0sCiAgICAvKioKICAgICAqIEByZXR1cm4gdmlzaWJsZSBpdGVtcyBpbiBob3Jpem9udGFsIGxpc3QgYXQgdGhlIGN1cnJlbnQgd2lkdGgvc3RhdGUKICAgICAqLwogICAgX3NpemUoKSB7CiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd29ya2luZ1dpZHRoOwogICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5yZXNwb25zaXZlLmZpbmQoKHZhbHVlKSA9PiB7CiAgICAgICAgcmV0dXJuICgKICAgICAgICAgICghdmFsdWUuc3RhcnQgfHwgdmFsdWUuc3RhcnQgPD0gd2lkdGgpICYmCiAgICAgICAgICAoIXZhbHVlLmVuZCB8fCB2YWx1ZS5lbmQgPj0gd2lkdGgpCiAgICAgICAgKTsKICAgICAgfSkuc2l6ZTsKICAgIH0sCiAgICAvKioKICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZXJlIGlzIHByZXYgc2V0IG9mIGl0ZW1zIGZvciBuYXZpZ2F0aW9uCiAgICAgKiBAcHJpdmF0ZSBpbnRlcm5hbCB1c2UKICAgICAqLwogICAgX2hhc05leHQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPiB0aGlzLnBvc2l0aW9uICsgdGhpcy5fc2l6ZTsKICAgIH0sCiAgICAvKioKICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZXJlIGlzIG5leHQgc2V0IG9mIGl0ZW1zIGZvciBuYXZpZ2F0aW9uCiAgICAgKiBAcHJpdmF0ZSBpbnRlcm5hbCB1c2UKICAgICAqLwogICAgX2hhc1ByZXYoKSB7CiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID4gMDsKICAgIH0sCiAgfSwKICBtZXRob2RzOiB7CiAgICAvKioKICAgICAqIEBwYXJhbSBwb3NpdGlvbiBvZiBpdGVtIHRvIHNjcm9sbCB0bwogICAgICovCiAgICBnbyhwb3NpdGlvbikgewogICAgICBjb25zdCBtYXhQb3NpdGlvbiA9IHRoaXMuX2xlbmd0aCAtIHRoaXMuX3NpemU7CiAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiA+IG1heFBvc2l0aW9uID8gbWF4UG9zaXRpb24gOiBwb3NpdGlvbjsKICAgICAgY29uc3QgbGVmdCA9CiAgICAgICAgdGhpcy5faXRlbVdpZHRoICogdGhpcy5wb3NpdGlvbiArCiAgICAgICAgdGhpcy5wb3NpdGlvbiAqIHRoaXMuX29wdGlvbnMuaXRlbS5wYWRkaW5nOwogICAgICB0aGlzLiRyZWZzLmxpc3Quc2Nyb2xsVG8oeyB0b3A6IDAsIGxlZnQ6IGxlZnQsIGJlaGF2aW9yOiAic21vb3RoIiB9KTsKICAgIH0sCiAgICAvKioKICAgICAqIFJ1biBhdXRvUGxheSBzbGlkZSBzaG93CiAgICAgKi8KICAgIHJ1bkF1dG9QbGF5KCkgewogICAgICB0aGlzLmF1dG9QbGF5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgKICAgICAgICBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuYXV0b3BsYXkucmVwZWF0ICYmCiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT09IHRoaXMuX2xlbmd0aCAtIHRoaXMuX3NpemUKICAgICAgICAgICkgewogICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDsKICAgICAgICAgICAgdGhpcy5nbyh0aGlzLnBvc2l0aW9uKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTsKICAgICAgICAgICAgdGhpcy5nbyh0aGlzLnBvc2l0aW9uKTsKICAgICAgICAgIH0KICAgICAgICB9LmJpbmQodGhpcyksCiAgICAgICAgdGhpcy5fb3B0aW9ucy5hdXRvcGxheS5zcGVlZAogICAgICApOwogICAgfSwKICAgIC8qKgogICAgICogU3RvcCBhdXRvUGxheSBzbGlkZSBzaG93CiAgICAgKi8KICAgIHN0b3BBdXRvUGxheSgpIHsKICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9QbGF5SW50ZXJ2YWwpOwogICAgfSwKICAgIC8qKgogICAgICogR28gdG8gYSBzZXQgb2YgcHJldmlvdXMgaXRlbXMKICAgICAqLwogICAgcHJldigpIHsKICAgICAgdGhpcy5nbyh0aGlzLnBvc2l0aW9uIC0gdGhpcy5fc2l6ZSk7CiAgICB9LAogICAgLyoqCiAgICAgKiBHbyB0byBhIHNldCBvZiBuZXh0IGl0ZW1zCiAgICAgKi8KICAgIG5leHQoKSB7CiAgICAgIHRoaXMuZ28odGhpcy5wb3NpdGlvbiArIHRoaXMuX3NpemUpOwogICAgfSwKICAgIC8qKgogICAgICogT24gaG9yaXpvbnRhbCBzY3JvbGwgcmUtZXZhbHVhdGUgdGhlIGFjdHVhbCBwb3NpdGlvbgogICAgICovCiAgICBzY3JvbGxIYW5kbGVyKCkgewogICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxUaW1lcik7CiAgICAgIC8vUmVuZXcgdGltZXIKICAgICAgdGhpcy5zY3JvbGxUaW1lciA9IHNldFRpbWVvdXQoCiAgICAgICAgZnVuY3Rpb24gKCkgewogICAgICAgICAgY29uc3QgcGFyZW50TGVmdE9mZnNldCA9IHRoaXMuJHJlZnNbImxpc3QiXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQogICAgICAgICAgICAubGVmdDsKICAgICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHsKICAgICAgICAgICAgY29uc3QgaXRlbUxlZnRPZmZzZXQgPSB0aGlzLiRyZWZzLml0ZW1bCiAgICAgICAgICAgICAgaW5kZXgKICAgICAgICAgICAgXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0OwogICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoaXRlbUxlZnRPZmZzZXQgLSBwYXJlbnRMZWZ0T2Zmc2V0KTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGl0ZW1zLmluZGV4T2YoTWF0aC5taW4oLi4uaXRlbXMpKTsKICAgICAgICB9LmJpbmQodGhpcyksCiAgICAgICAgNTAKICAgICAgKTsKICAgIH0sCiAgfSwKICB3YXRjaDogewogICAgIm9wdGlvbnMuYXV0b3BsYXkucGxheSI6IGZ1bmN0aW9uIChuZXdWYWwsIG9sZFZhbCkgewogICAgICBpZiAoIW5ld1ZhbCkgewogICAgICAgIHRoaXMuc3RvcEF1dG9QbGF5KCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5ydW5BdXRvUGxheSgpOwogICAgICB9CiAgICB9LAogIH0sCn07Cg=="},{"version":3,"sources":["vue-horizontal-list.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vue-horizontal-list.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"vue-horizontal-list\" ref=\"container\">\n    <div class=\"vhl-navigation\" v-if=\"width.window > _options.navigation.start\">\n      <div @click=\"prev\" v-if=\"_hasPrev\" class=\"vhl-btn-left\">\n        <slot name=\"nav-prev\">\n          <svg\n            :fill=\"_options.navigation.color\"\n            width=\"32px\"\n            height=\"32px\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              d=\"M10.757 12l4.95 4.95a1 1 0 1 1-1.414 1.414l-5.657-5.657a1 1 0 0 1 0-1.414l5.657-5.657a1 1 0 0 1 1.414 1.414L10.757 12z\"\n            />\n          </svg>\n        </slot>\n      </div>\n\n      <div @click=\"next\" v-if=\"_hasNext\" class=\"vhl-btn-right\">\n        <slot name=\"nav-next\">\n          <svg\n            :fill=\"_options.navigation.color\"\n            width=\"32px\"\n            height=\"32px\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              d=\"M13.314 12.071l-4.95-4.95a1 1 0 0 1 1.414-1.414l5.657 5.657a1 1 0 0 1 0 1.414l-5.657 5.657a1 1 0 0 1-1.414-1.414l4.95-4.95z\"\n            />\n          </svg>\n        </slot>\n      </div>\n    </div>\n\n    <div class=\"vhl-container\" :style=\"_style.container\">\n      <div\n        class=\"vhl-list\"\n        ref=\"list\"\n        :class=\"_options.list.class\"\n        :style=\"_style.list\"\n        @scroll=\"scrollHandler\"\n      >\n        <!-- <div\n          v-for=\"item in _items\"\n          ref=\"item\"\n          class=\"vhl-item\"\n          :class=\"_options.item.class\"\n          :style=\"_style.item\"\n        > -->\n          <slot v-if=\"item.type === 'start'\" name=\"start\"></slot>\n          <slot v-else-if=\"item.type === 'end'\" name=\"end\"></slot>\n          <slot v-else-if=\"item.type === 'item'\" v-bind:item=\"item.item\">{{\n            item\n          }}</slot>\n        </div>\n\n        <div :style=\"_style.tail\"></div>\n      </div>\n    </div>\n  \n</template>\n\n<script>\nexport default {\n  name: \"VueHorizontalList\",\n  props: {\n    /**\n     * items to display in horizontal-list\n     */\n    items: {\n      type: Array,\n      required: true,\n    },\n    /**\n     * item.class = css class for each individual item.\n     * item.padding = padding between each item in the list.\n     *\n     * list.class = css class for the parent of item\n     * list.windowed = maximum width of the list it can extend to, basically the container max-width\n     * list.padding = padding of the list, if container < windowed what is the left-right padding of the list\n     *\n     * responsive breakpoints to calculate how many items to show in the list at each width interval\n     * Examples:\n     * [{size: 5}] show 5 items regardless\n     * [{end: 992, size: 3}},{size: 4}] < 992 show 3 items, else show 4 items\n     * [{end: 576, size: 1}, {start: 576, end: 992, size: 2}, {size: 3}] < 576 show 1, 576 - 992 show 2, else show 3\n     *\n     * These are the default responsive fallback, if you don't have a catch all, it will fallback to this.\n     * [{end: 576, size: 1},\n     * {start: 576, end: 768, size: 2},\n     * {start: 768, end: 992, size: 3},\n     * {start: 992, end: 1200, size: 4},\n     * {start: 1200, size: 5}]\n     */\n    options: {\n      type: Object,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      /**\n       * Current item position of list\n       */\n      position: 0,\n      /**\n       * Width of item, list and window\n       */\n      width: {\n        container: 0,\n        window: 576,\n      },\n      /**\n       * Debounce timer of the scroll\n       */\n      scrollTimer: null,\n      /**\n       * Interval of the autoPlay\n       */\n      autoPlayInterval: null,\n    };\n  },\n  mounted() {\n    this.$resize = () => {\n      this.width.window = window.innerWidth;\n      this.width.container = this.$refs.container.clientWidth;\n    };\n    // TODO(fuxing): Need to re-do this\n    // Added a simple SSR fix, need to look into it for optimization in the future\n    require(\"smoothscroll-polyfill\").polyfill();\n    this.$resize();\n    window.addEventListener(\"resize\", this.$resize);\n    if (this._options.position.start) {\n      this.$nextTick(() => {\n        this.go(this._options.position.start);\n      });\n    }\n    if (this._options.autoplay.play) {\n      this.runAutoPlay();\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener(\"resize\", this.$resize);\n    if (this.autoPlayInterval) {\n      clearInterval(this.autoPlayInterval);\n    }\n  },\n  computed: {\n    _items() {\n      return [\n        ...(this.$slots[\"start\"] ? [{ type: \"start\" }] : []),\n        ...this.items.map((value) => ({ type: \"item\", item: value })),\n        ...(this.$slots[\"end\"] ? [{ type: \"end\" }] : []),\n      ];\n    },\n    _length() {\n      return this._items.length;\n    },\n    _options() {\n      const options = this.options;\n      return {\n        navigation: {\n          start: options?.navigation?.start ?? 992,\n          // TODO(fuxing): Deprecate this in favor of navigation slot\n          color: options?.navigation?.color ?? \"#000\",\n        },\n        item: {\n          class: options?.item?.class ?? \"\",\n          padding: options?.item?.padding ?? 16,\n        },\n        list: {\n          class: options?.list?.class ?? \"\",\n          windowed: options?.list?.windowed ?? 1200,\n          padding: options?.list?.padding ?? 24,\n        },\n        responsive: [\n          ...(options?.responsive ?? []),\n          // Fallback default responsive\n          { end: 576, size: 1 },\n          { start: 576, end: 768, size: 2 },\n          { start: 768, end: 992, size: 3 },\n          { start: 992, end: 1200, size: 4 },\n          { start: 1200, size: 5 },\n        ],\n        position: {\n          start: options?.position?.start ?? 0,\n        },\n        autoplay: {\n          play: options?.autoplay?.play ?? false,\n          speed: options?.autoplay?.speed ?? 2000,\n          repeat: options?.autoplay?.repeat ?? false,\n        },\n      };\n    },\n    _style() {\n      const style = {\n        container: {},\n        list: {},\n        item: {},\n        tail: {},\n      };\n      const workingWidth = this._workingWidth;\n      const size = this._size;\n      // Full Screen Mode\n      if (this.width.window < this._options.list.windowed) {\n        style.container.marginLeft = `-${this._options.list.padding}px`;\n        style.container.marginRight = `-${this._options.list.padding}px`;\n        style.item.width = `${\n          (workingWidth - (size - 1) * this._options.item.padding) / size\n        }px`;\n        style.item.paddingLeft = `${this._options.list.padding}px`;\n        style.item.paddingRight = `${this._options.item.padding}px`;\n        style.item.marginRight = `-${this._options.list.padding}px`;\n      }\n      // Windowed Mode\n      else {\n        style.item.paddingLeft = `${this._options.item.padding / 2}px`;\n        style.item.paddingRight = `${this._options.item.padding / 2}px`;\n        style.container.marginLeft = `-${this._options.item.padding / 2}px`;\n        style.container.marginRight = `-${this._options.item.padding / 2}px`;\n        style.item.width = `${\n          (workingWidth - (size - 1) * this._options.item.padding) / size\n        }px`;\n      }\n      return style;\n    },\n    _itemWidth() {\n      return (\n        (this._workingWidth - (this._size - 1) * this._options.item.padding) /\n        this._size\n      );\n    },\n    /**\n     * @return number actual width of the container\n     */\n    _workingWidth() {\n      // Full Screen Mode\n      if (this.width.window < this._options.list.windowed) {\n        return this.width.window - this._options.list.padding * 2;\n      }\n      // Windowed Mode\n      else {\n        return this.width.container;\n      }\n    },\n    /**\n     * @return visible items in horizontal list at the current width/state\n     */\n    _size() {\n      const width = this._workingWidth;\n      return this._options.responsive.find((value) => {\n        return (\n          (!value.start || value.start <= width) &&\n          (!value.end || value.end >= width)\n        );\n      }).size;\n    },\n    /**\n     * @return boolean whether there is prev set of items for navigation\n     * @private internal use\n     */\n    _hasNext() {\n      return this._length > this.position + this._size;\n    },\n    /**\n     * @return boolean whether there is next set of items for navigation\n     * @private internal use\n     */\n    _hasPrev() {\n      return this.position > 0;\n    },\n  },\n  methods: {\n    /**\n     * @param position of item to scroll to\n     */\n    go(position) {\n      const maxPosition = this._length - this._size;\n      this.position = position > maxPosition ? maxPosition : position;\n      const left =\n        this._itemWidth * this.position +\n        this.position * this._options.item.padding;\n      this.$refs.list.scrollTo({ top: 0, left: left, behavior: \"smooth\" });\n    },\n    /**\n     * Run autoPlay slide show\n     */\n    runAutoPlay() {\n      this.autoPlayInterval = setInterval(\n        function () {\n          if (\n            this._options.autoplay.repeat &&\n            this.position === this._length - this._size\n          ) {\n            this.position = 0;\n            this.go(this.position);\n          } else {\n            this.position += 1;\n            this.go(this.position);\n          }\n        }.bind(this),\n        this._options.autoplay.speed\n      );\n    },\n    /**\n     * Stop autoPlay slide show\n     */\n    stopAutoPlay() {\n      clearInterval(this.autoPlayInterval);\n    },\n    /**\n     * Go to a set of previous items\n     */\n    prev() {\n      this.go(this.position - this._size);\n    },\n    /**\n     * Go to a set of next items\n     */\n    next() {\n      this.go(this.position + this._size);\n    },\n    /**\n     * On horizontal scroll re-evaluate the actual position\n     */\n    scrollHandler() {\n      clearTimeout(this.scrollTimer);\n      //Renew timer\n      this.scrollTimer = setTimeout(\n        function () {\n          const parentLeftOffset = this.$refs[\"list\"].getBoundingClientRect()\n            .left;\n          let items = this._items.map((item, index) => {\n            const itemLeftOffset = this.$refs.item[\n              index\n            ].getBoundingClientRect().left;\n            return Math.abs(itemLeftOffset - parentLeftOffset);\n          });\n          this.position = items.indexOf(Math.min(...items));\n        }.bind(this),\n        50\n      );\n    },\n  },\n  watch: {\n    \"options.autoplay.play\": function (newVal, oldVal) {\n      if (!newVal) {\n        this.stopAutoPlay();\n      } else {\n        this.runAutoPlay();\n      }\n    },\n  },\n};\n</script>\n<style scoped>\n.vue-horizontal-list {\n  position: relative;\n}\n.vhl-navigation {\n  display: flex;\n  align-items: center;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  margin-top: -6px;\n}\n.vhl-btn-left,\n.vhl-btn-right {\n  width: 48px;\n  height: 48px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 24px;\n  background: white;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n  z-index: 2;\n}\n.vhl-btn-left:hover,\n.vhl-btn-right:hover {\n  cursor: pointer;\n}\n.vhl-btn-left {\n  margin-left: -24px;\n  margin-right: auto;\n}\n.vhl-btn-right {\n  margin-left: auto;\n  margin-right: -24px;\n}\n.vhl-container {\n  overflow-y: hidden;\n  height: 100%;\n  margin-bottom: -24px;\n}\n.vhl-list {\n  display: flex;\n  padding-bottom: 24px;\n  margin-bottom: -24px;\n  overflow-x: scroll;\n  overflow-y: hidden;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n  scroll-snap-type: x mandatory;\n}\n.vhl-item {\n  box-sizing: content-box;\n  padding-top: 24px;\n  padding-bottom: 24px;\n  z-index: 1;\n  /* Prevent content from collapsing when empty. E.g. image while loading height=0. */\n  min-height: 1px;\n}\n.vhl-list > * {\n  scroll-snap-align: start;\n  flex-shrink: 0;\n}\n</style>"]}]}